"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGrep = exports.shouldTestRun = exports.shouldTestRunTitle = exports.shouldTestRunTags = exports.parseTagsGrep = exports.parseFullTitleGrep = exports.parseTitleGrep = void 0;
const parseTitleGrep = (s) => {
    if (!s || typeof s !== 'string') {
        return null;
    }
    s = s.trim();
    if (s.startsWith('-')) {
        return {
            title: s.substring(1),
            invert: true,
        };
    }
    return {
        title: s,
        invert: false,
    };
};
exports.parseTitleGrep = parseTitleGrep;
const parseFullTitleGrep = (s) => {
    if (!s || typeof s !== 'string') {
        return [];
    }
    return s.split(';').map(exports.parseTitleGrep);
};
exports.parseFullTitleGrep = parseFullTitleGrep;
const parseTagsGrep = (s) => {
    if (!s) {
        return [];
    }
    const explicitNotTags = [];
    const ORS = s
        .split(/[ ,]/)
        .filter(Boolean)
        .map((part) => {
        if (part.startsWith('--')) {
            explicitNotTags.push({
                tag: part.slice(2),
                invert: true,
            });
            return;
        }
        const parsed = part.split('+').map((tag) => {
            if (tag.startsWith('-')) {
                return {
                    tag: tag.slice(1),
                    invert: true,
                };
            }
            return {
                tag,
                invert: false,
            };
        });
        return parsed;
    });
    const ORS_filtered = ORS.filter((x) => x !== undefined);
    if (explicitNotTags.length > 0) {
        ORS_filtered.forEach((OR, index) => {
            ORS_filtered[index] = OR.concat(explicitNotTags);
        });
        if (ORS_filtered.length === 0) {
            ORS_filtered[0] = explicitNotTags;
        }
    }
    return ORS_filtered;
};
exports.parseTagsGrep = parseTagsGrep;
const shouldTestRunTags = (parsedGrepTags, tags = []) => {
    if (!parsedGrepTags.length) {
        return true;
    }
    const onePartMatched = parsedGrepTags.some((orPart) => {
        const everyAndPartMatched = orPart.every((p) => {
            if (p.invert) {
                return !tags.includes(p.tag);
            }
            return tags.includes(p.tag);
        });
        return everyAndPartMatched;
    });
    return onePartMatched;
};
exports.shouldTestRunTags = shouldTestRunTags;
const shouldTestRunTitle = (parsedGrep, testName) => {
    if (!testName) {
        return true;
    }
    if (!parsedGrep) {
        return true;
    }
    if (!Array.isArray(parsedGrep)) {
        console.error('Invalid parsed title grep');
        console.error(parsedGrep);
        throw new Error('Expected title grep to be an array');
    }
    if (!parsedGrep.length) {
        return true;
    }
    const inverted = parsedGrep.filter((g) => g.invert);
    const straight = parsedGrep.filter((g) => !g.invert);
    return (inverted.every((titleGrep) => !testName.includes(titleGrep.title)) &&
        (!straight.length ||
            straight.some((titleGrep) => testName.includes(titleGrep.title))));
};
exports.shouldTestRunTitle = shouldTestRunTitle;
const shouldTestRun = (parsedGrep, testName, tags = [], grepUntagged = false) => {
    if (grepUntagged) {
        return !tags.length;
    }
    return ((0, exports.shouldTestRunTitle)(parsedGrep.title, testName) &&
        (0, exports.shouldTestRunTags)(parsedGrep.tags, tags));
};
exports.shouldTestRun = shouldTestRun;
const parseGrep = (titlePart, tags) => {
    return {
        title: (0, exports.parseFullTitleGrep)(titlePart),
        tags: (0, exports.parseTagsGrep)(tags),
    };
};
exports.parseGrep = parseGrep;
